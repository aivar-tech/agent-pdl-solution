// ========== UI Section Info ===========
const sectionTooltips = {
  'problem_statement': 'What is the core problem and context?',
  'goals_and_success_metrics': 'List of goals with a measurable success metric for each.',
  'user_stories': 'User stories, each with a role and story.',
  'constraints': 'Any technical, legal, or business constraints.',
  'milestones': 'Key implementation milestones and target dates.',
  'hypothesis': 'Hypothesis statement.',
  'rationale': 'Reasoning behind the hypothesis.',
  'test': 'How to test/validate the hypothesis.'
};

const agentMeta = {
  scope_document: {
    label: 'Scoping Agent',
    icon: 'üß≠',
    cardId: 'scope-card'
  },
  data_analysis: {
    label: 'Data Analysis Agent',
    icon: 'üìä',
    cardId: 'data-card'
  },
  hypotheses: {
    label: 'Hypothesis Generation Agent',
    icon: 'üí°',
    cardId: 'hypo-card'
  },
  hypothesis_test_results: {
    label: 'Hypothesis Testing Agent',
    icon: 'üß™',
    cardId: 'hypo-test-card'
  }
};

// ========== Section Accordion Renderer ===========
function renderSectionAccordion(sectionKey, value) {
  const tooltip = sectionTooltips[sectionKey] ? `<span class="tooltip" title="${sectionTooltips[sectionKey]}">‚ìò</span>` : '';
  let contentHtml = '';
  if (Array.isArray(value)) {
    if (value.length === 0) {
      contentHtml = '<div class="section-content">(None)</div>';
    } else if (typeof value[0] === 'object') {
      // List of objects
      contentHtml = '<div class="section-content section-list">';
      value.forEach((obj, idx) => {
        contentHtml += '<div style="margin-bottom:0.7em;">';
        Object.entries(obj).forEach(([k, v]) => {
          contentHtml += `<div><b>${k.replace(/_/g,' ').replace(/\b\w/g,c=>c.toUpperCase())}:</b> <span style="white-space:pre-line;">${v}</span></div>`;
        });
        contentHtml += '</div>';
      });
      contentHtml += '</div>';
    } else {
      // List of strings
      contentHtml = '<ul class="section-content section-list">' + value.map(v => `<li>${v}</li>`).join('') + '</ul>';
    }
  } else if (typeof value === 'object' && value !== null) {
    contentHtml = '<div class="section-content">';
    Object.entries(value).forEach(([k, v]) => {
      if (typeof v === 'object' && v !== null) {
        // For nested objects like hypothesis test results
        contentHtml += `<div class="nested-object"><b>${k.replace(/_/g,' ').replace(/\b\w/g,c=>c.toUpperCase())}:</b>`;
        contentHtml += '<div class="nested-content">';
        Object.entries(v).forEach(([subK, subV]) => {
          // Special formatting for status field in hypothesis testing
          if (subK === 'status') {
            const statusClass = subV.toLowerCase().includes('support') ? 'status-supported' : 
                              subV.toLowerCase().includes('contradict') ? 'status-contradicted' : 'status-insufficient';
            contentHtml += `<div><b>${subK.replace(/_/g,' ').replace(/\b\w/g,c=>c.toUpperCase())}:</b> <span class="${statusClass}">${subV}</span></div>`;
          } else if (subK === 'confidence') {
            // Format confidence as percentage with color coding
            const confidenceValue = parseInt(subV);
            const confidenceClass = confidenceValue >= 70 ? 'confidence-high' : 
                                   confidenceValue >= 40 ? 'confidence-medium' : 'confidence-low';
            contentHtml += `<div><b>${subK.replace(/_/g,' ').replace(/\b\w/g,c=>c.toUpperCase())}:</b> <span class="${confidenceClass}">${confidenceValue}%</span></div>`;
          } else {
            contentHtml += `<div><b>${subK.replace(/_/g,' ').replace(/\b\w/g,c=>c.toUpperCase())}:</b> <span style="white-space:pre-line;">${subV}</span></div>`;
          }
        });
        contentHtml += '</div></div>';
      } else {
        contentHtml += `<div><b>${k.replace(/_/g,' ').replace(/\b\w/g,c=>c.toUpperCase())}:</b> <span style="white-space:pre-line;">${v}</span></div>`;
      }
    });
    contentHtml += '</div>';
  } else {
    contentHtml = `<div class="section-content">${value ? value : '(None)'}</div>`;
  }
  return `
    <div class="section-accordion">
      <div class="section-header" tabindex="0" role="button" aria-expanded="false">
        <span>${sectionKey.replace(/_/g,' ').replace(/\b\w/g,c=>c.toUpperCase())}</span>
        ${tooltip}
        <span class="accordion-arrow" style="margin-left:auto;">&#x25BC;</span>
      </div>
      ${contentHtml}
    </div>
  `;
}

// ========== Agent Card Renderer ===========
function renderAgentCard(agentKey, agentData) {
  const meta = agentMeta[agentKey];
  let html = `<section class="agent-card" id="${meta.cardId}">
    <div class="agent-header">
      <span class="agent-icon">${meta.icon}</span>
      <span class="agent-title">${meta.label}</span>
    </div>
  `;
  if (agentData.error) {
    html += `<div class="error-message"><b>ERROR:</b> ${agentData.error}</div>`;
  } else if (agentKey === 'hypothesis_test_results') {
    // Special handling for hypothesis test results which are stored as a JSON string
    html += '<div class="agent-sections">';
    try {
      // Try to parse the JSON string
      let testResults;
      if (typeof agentData === 'string') {
        // Extract the JSON part from the string
        // Look for the pattern where JSON starts (after any text and newlines)
        const jsonMatch = agentData.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
          // Parse the extracted JSON
          testResults = JSON.parse(jsonMatch[0]);
        } else {
          // If no JSON pattern found, try parsing the whole string
          testResults = JSON.parse(agentData);
        }
      } else if (typeof agentData === 'object') {
        // If it's already an object, use it directly
        testResults = agentData;
      }
      
      if (testResults) {
        Object.entries(testResults).forEach(([k, v]) => {
          html += renderSectionAccordion(k, v);
        });
      }
    } catch (err) {
      console.error('Error parsing hypothesis test results:', err);
      // Fallback to displaying as text if parsing fails
      html += `<div class="agent-output-md">${marked.parse(agentData.toString())}</div>`;
    }
    html += '</div>';
  } else if (agentData.sections) {
    html += '<div class="agent-sections">';
    if (Array.isArray(agentData.sections)) {
      // List of objects (for hypotheses)
      agentData.sections.forEach((obj, idx) => {
        html += renderSectionAccordion(`Hypothesis ${idx+1}`, obj);
      });
    } else if (typeof agentData.sections === 'object') {
      Object.entries(agentData.sections).forEach(([k, v]) => {
        html += renderSectionAccordion(k, v);
      });
    }
    html += '</div>';
  } else if (agentData.markdown) {
    // Render markdown output if present
    html += `<div class="agent-output-md">${marked.parse(agentData.markdown)}</div>`;
  } else if (agentData.text) {
    // Fallback: treat as markdown for rich formatting
    html += `<div class="agent-output-md">${marked.parse(agentData.text)}</div>`;
  }
  html += '</section>';
  return html;
}

// ========== File Upload Handling ===========
function handleFileSelect() {
  const fileInput = document.getElementById('document-upload');
  if (!fileInput) {
    console.error('File input element not found');
    return;
  }
  
  const fileNameDisplay = document.getElementById('file-name');
  if (!fileNameDisplay) {
    console.error('File name display element not found');
    return;
  }
  
  console.log('Setting up file input change listener');
  
  // Directly check if there's already a file selected (for page refresh cases)
  if (fileInput.files && fileInput.files[0]) {
    const fileName = fileInput.files[0].name;
    fileNameDisplay.textContent = fileName;
    fileNameDisplay.classList.add('has-file');
  }
  
  // Add event listener for future changes
  fileInput.addEventListener('change', function(event) {
    console.log('File input changed', event);
    if (this.files && this.files[0]) {
      const fileName = this.files[0].name;
      console.log('File selected:', fileName);
      fileNameDisplay.textContent = fileName;
      fileNameDisplay.classList.add('has-file');
    } else {
      console.log('No file selected');
      fileNameDisplay.textContent = 'No file selected';
      fileNameDisplay.classList.remove('has-file');
    }
  });
}

// ========== Workflow Submission ===========
async function submitWorkflow() {
  const briefElement = document.getElementById('brief');
  const brief = briefElement.value.trim();
  const rawData = document.getElementById('raw_data').value;
  const fileInput = document.getElementById('document-upload');
  const resultDiv = document.getElementById('result');
  
  // Validate that brief is not empty
  if (!brief) {
    resultDiv.innerHTML = `<div class="error-message"><b>Error:</b> Product brief is required. Please provide a description of your product or feature.</div>`;
    briefElement.focus();
    briefElement.classList.add('input-error');
    return;
  }
  
  // Remove error styling if it was previously applied
  briefElement.classList.remove('input-error');
  
  resultDiv.innerHTML = `
    <div style="padding:2em;text-align:center;">
      <div class="loading-spinner"></div>
      <div style="font-size:1.2em;color:#0f3d91;margin-top:1em;">Submitting request...</div>
    </div>
  `;

  try {
    // Create form data if we have a file
    if (fileInput.files && fileInput.files[0]) {
      console.log('File detected:', fileInput.files[0].name, 'Size:', fileInput.files[0].size);
      
      const formData = new FormData();
      formData.append('brief', brief);
      if (rawData) {
        formData.append('raw_data', rawData);
      }
      
      // Log file details before appending
      console.log('Appending file to FormData:', fileInput.files[0].name);
      formData.append('document', fileInput.files[0]);
      
      // Log FormData contents (for debugging)
      console.log('FormData entries:');
      for (let pair of formData.entries()) {
        console.log(pair[0], pair[1] instanceof File ? pair[1].name : pair[1]);
      }
      
      console.log('Sending request to /api/workflow-with-document');
      const response = await fetch('/api/workflow-with-document', {
        method: 'POST',
        body: formData
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Server responded with ${response.status}: ${errorText}`);
      }
      
      const data = await response.json();
      console.log('Response received:', data);
      handleWorkflowResponse(data, resultDiv);
    } else {
      // Regular JSON submission without file
      console.log('No file selected, using regular JSON submission');
      const response = await fetch('/api/workflow', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ brief, raw_data: rawData })
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Server responded with ${response.status}: ${errorText}`);
      }
      
      const data = await response.json();
      handleWorkflowResponse(data, resultDiv);
    }
  } catch (err) {
    console.error('Error submitting workflow:', err);
    resultDiv.innerHTML = `<div class="error-message"><b>Error:</b> ${err.message || err}</div>`;
  }
}

// Handle workflow response
function handleWorkflowResponse(data, resultDiv) {
  if (data.error) {
    resultDiv.innerHTML = `<div class="error-message"><b>Error:</b> ${data.error}</div>`;
  } else {
    // Show pending status
    resultDiv.innerHTML = `
      <div style="padding:2em;">
        <h3>Request Submitted</h3>
        <p>Request ID: ${data.request_id}</p>
        <p>Status: <span class="status-badge status-${data.status}">${data.status.toUpperCase()}</span></p>
        <p>Your request is being processed. Results will appear here when ready.</p>
        <div class="progress-indicator"><div class="progress-bar"></div></div>
      </div>
    `;
    
    // Refresh executions list
    loadExecutions();
    
    // Start polling for results
    pollExecutionStatus(data.request_id);
    
    // Smooth scroll to results
    setTimeout(()=>{
      resultDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }, 150);
  }
}

// ========== Execution Status Polling ===========
let activePolling = null;

// Track last completed execution ID
window.lastCompletedExecutionId = null;

async function pollExecutionStatus(requestId) {
  // Cancel any existing polling
  if (activePolling) {
    clearInterval(activePolling);
  }
  
  // Start polling
  activePolling = setInterval(async () => {
    try {
      const status = await fetchExecutionStatus(requestId);
      
      // Update UI based on status
      if (status.status === 'completed' || status.status === 'failed') {
        // Stop polling when complete or failed
        clearInterval(activePolling);
        activePolling = null;
        
        // Reset all agent status indicators
        resetAllAgentStatusIndicators();
        
        // Refresh executions list
        loadExecutions();
        
        // Display results if completed
        if (status.status === 'completed' && status.results) {
          // Store the execution ID for PDF export
          window.lastCompletedExecutionId = requestId;
          displayResults(status.results);
        } else if (status.status === 'failed') {
          const resultDiv = document.getElementById('result');
          resultDiv.innerHTML = `<div class="error-message">Execution failed: ${status.error || 'Unknown error'}</div>`;
        }
      } else {
        // Update progress indicator
        const resultDiv = document.getElementById('result');
        resultDiv.innerHTML = `
          <div style="padding:2em;">
            <h3>Processing Request</h3>
            <p>Request ID: ${status.request_id}</p>
            <p>Status: <span class="status-badge status-${status.status}">${status.status.toUpperCase()}</span></p>
            <p>Current step: ${status.current_step || 'Initializing...'}</p>
            <div class="progress-indicator"><div class="progress-bar"></div></div>
          </div>
        `;
        
        // Update agent status indicators based on current step
        updateAgentStatusIndicators(status.current_step);
      }
    } catch (err) {
      console.error('Error polling execution status:', err);
    }
  }, 2000); // Poll every 2 seconds
}

async function fetchExecutionStatus(requestId) {
  const response = await fetch(`/api/workflow/${requestId}`);
  if (!response.ok) {
    throw new Error(`Failed to fetch execution status: ${response.statusText}`);
  }
  return await response.json();
}

// ========== Agent Status Indicators ===========
function updateAgentStatusIndicators(currentStep) {
  // Reset all indicators first
  resetAllAgentStatusIndicators();
  
  // Map the current step to the corresponding agent
  const step = currentStep ? currentStep.toLowerCase() : '';
  
  if (step.includes('scoping') || step.includes('analyzing brief')) {
    setAgentStatusActive('nav-scope');
  } else if (step.includes('data') || step.includes('analyzing data')) {
    setAgentStatusActive('nav-data');
  } else if (step.includes('hypothesis') || step.includes('generating hypotheses')) {
    setAgentStatusActive('nav-hypo');
  } else if (step.includes('testing') || step.includes('evaluating hypotheses')) {
    setAgentStatusActive('nav-test');
  }
}

function setAgentStatusActive(agentId) {
  const agentElement = document.getElementById(agentId);
  if (agentElement) {
    const statusIndicator = agentElement.querySelector('.agent-status');
    if (statusIndicator) {
      statusIndicator.classList.add('active');
      
      // Add pulsing animation
      statusIndicator.style.backgroundColor = '#F1C93B'; // Gold color for active agent
      statusIndicator.style.boxShadow = '0 0 10px rgba(241, 201, 59, 0.7)'; // Glow effect
    }
  }
}

function resetAllAgentStatusIndicators() {
  const agentElements = document.querySelectorAll('.agent-link');
  agentElements.forEach(agent => {
    const statusIndicator = agent.querySelector('.agent-status');
    if (statusIndicator) {
      statusIndicator.classList.remove('active');
      statusIndicator.style.backgroundColor = ''; // Reset to default
      statusIndicator.style.boxShadow = ''; // Reset glow effect
    }
  });
}

// ========== Display Results ===========
function displayResults(results) {
  const resultDiv = document.getElementById('result');
  resultDiv.innerHTML = '';
  const exportBtn = document.getElementById('export-pdf-btn');
  const previewBtn = document.getElementById('preview-pdf-btn');
  
  if (results.error) {
    resultDiv.innerHTML = `<div class="error-message"><b>ERROR:</b> ${results.error}</div>`;
    exportBtn.style.display = 'none';
    previewBtn.style.display = 'none';
    return;
  }
  
  // Display each agent's output
  for (const [agentKey, agentData] of Object.entries(results)) {
    if (agentMeta[agentKey]) {
      resultDiv.innerHTML += renderAgentCard(agentKey, agentData);
    }
  }
  
  // Show export and preview buttons if we have results
  if (Object.keys(results).length > 0) {
    exportBtn.style.display = 'flex';
    previewBtn.style.display = 'flex';
  } else {
    exportBtn.style.display = 'none';
    previewBtn.style.display = 'none';
  }
  
  // Initialize accordions for the new content
  initAccordions();
  
  // Reset all agent status indicators when results are displayed
  resetAllAgentStatusIndicators();
}

// ========== Load Executions ===========
async function loadExecutions() {
  const executionsListDiv = document.getElementById('executions-list');
  
  try {
    const response = await fetch('/api/workflows');
    if (!response.ok) {
      throw new Error(`Failed to fetch executions: ${response.statusText}`);
    }
    
    const executions = await response.json();
    
    if (executions.length === 0) {
      executionsListDiv.innerHTML = '<div class="loading-text">No executions found</div>';
      return;
    }
    
    let html = '';
    executions.forEach(execution => {
      // Format the brief for display (truncate if too long)
      const briefDisplay = execution.brief.length > 30 ? 
        execution.brief.substring(0, 30) + '...' : 
        execution.brief;
      
      // Format the date
      const date = new Date(execution.created_at);
      const dateStr = `${date.toLocaleDateString()} ${date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
      
      html += `
        <div class="execution-item" data-id="${execution.request_id}">
          <div class="execution-title">${briefDisplay}</div>
          <div class="execution-status">
            <span class="status-indicator status-${execution.status}"></span>
            ${execution.status} - ${dateStr}
          </div>
        </div>
      `;
    });
    
    executionsListDiv.innerHTML = html;
    
    // Add click event listeners to execution items
    document.querySelectorAll('.execution-item').forEach(item => {
      item.addEventListener('click', () => {
        // Remove selected class from all items
        document.querySelectorAll('.execution-item').forEach(i => {
          i.classList.remove('selected');
        });
        
        // Add selected class to clicked item
        item.classList.add('selected');
        
        // Load the execution
        const requestId = item.dataset.id;
        loadExecution(requestId);
      });
    });
    
  } catch (err) {
    executionsListDiv.innerHTML = `<div class="loading-text">Error loading executions: ${err.message}</div>`;
    console.error('Error loading executions:', err);
  }
}

async function loadExecution(requestId) {
  const resultDiv = document.getElementById('result');
  resultDiv.innerHTML = `
    <div style="padding:2em;text-align:center;">
      <div class="loading-spinner"></div>
      <div style="font-size:1.2em;color:#0f3d91;margin-top:1em;">Loading execution results...</div>
    </div>
  `;
  
  try {
    const status = await fetchExecutionStatus(requestId);
    
    if (status.status === 'completed' && status.results) {
      // Display completed results
      displayResults(status.results);
    } else if (status.status === 'failed') {
      // Display error
      resultDiv.innerHTML = `<div class="error-message">Execution failed: ${status.error || 'Unknown error'}</div>`;
    } else {
      // Display in-progress status and start polling
      resultDiv.innerHTML = `
        <div style="padding:2em;">
          <h3>Processing Request</h3>
          <p>Request ID: ${status.request_id}</p>
          <p>Status: <span class="status-badge status-${status.status}">${status.status.toUpperCase()}</span></p>
          <p>Current step: ${status.current_step || 'Initializing...'}</p>
          <div class="progress-indicator"><div class="progress-bar"></div></div>
        </div>
      `;
      
      // Start polling for updates
      pollExecutionStatus(requestId);
    }
    
  } catch (err) {
    resultDiv.innerHTML = `<div class="error-message">Error loading execution: ${err.message}</div>`;
    console.error('Error loading execution:', err);
  }
}

// ========== Example Templates ===========
const templates = [
  {
    label: "Launch new Rummy Tournament (Games24x7)",
    brief: "Launch a new real-money online rummy tournament format for Games24x7.",
    data: "Historical tournaments show peak engagement during weekends and holidays. Previous format changes impacted retention by +10%."
  },
  {
    label: "AI-Powered Game Recommendations (Games24x7)",
    brief: "Add AI-powered personalized game recommendations to the Games24x7 app.",
    data: "User segmentation and session data available. Prior recommendation attempts had limited uplift (3-5%)."
  },
  {
    label: "Gametech: Real-time Anti-Fraud System",
    brief: "Implement a real-time fraud detection system for digital gaming transactions.",
    data: "Recent spike in suspicious withdrawal patterns. Current rules-based system has 8% false positive."
  },
  {
    label: "Gametech: LiveOps Event Automation",
    brief: "Automate LiveOps event scheduling and reward distribution for multiplayer games.",
    data: "Manual events require 10+ hours/week. Engagement increases 12% during well-timed events."
  }
];

const examplesPanel = document.getElementById('examples-panel');

function renderExampleCards() {
  examplesPanel.innerHTML = '';
  templates.forEach((tpl, idx) => {
    const card = document.createElement('div');
    card.className = 'example-card';
    card.tabIndex = 0;
    card.setAttribute('role', 'button');
    card.setAttribute('aria-label', tpl.label);
    card.innerHTML = `
      <div class="example-title">${tpl.label}</div>
      <div class="example-brief"><b>Brief:</b> ${tpl.brief}</div>
      <div class="example-data"><b>Data:</b> ${tpl.data}</div>
    `;
    card.addEventListener('click', () => selectTemplate(idx));
    card.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') selectTemplate(idx); });
    examplesPanel.appendChild(card);
  });
}

function selectTemplate(idx) {
  // Highlight selected card
  Array.from(document.getElementsByClassName('example-card')).forEach((el, i) => {
    el.classList.toggle('active', i === idx);
  });
  // Fill form
  document.getElementById('brief').value = templates[idx].brief;
}

// ========== Initialize Accordions ===========
function initAccordions() {
  document.querySelectorAll('.section-header').forEach(header => {
    header.addEventListener('click', function() {
      this.classList.toggle('active');
      this.setAttribute('aria-expanded', this.classList.contains('active'));
      const content = this.nextElementSibling;
      if (content.style.maxHeight) {
        content.style.maxHeight = null;
      } else {
        content.style.maxHeight = content.scrollHeight + 'px';
      }
      const arrow = this.querySelector('.accordion-arrow');
      if (arrow) {
        arrow.style.transform = this.classList.contains('active') ? 'rotate(180deg)' : '';
      }
    });
  });
}

// ========== PDF Export Functionality ===========
async function exportToPDF() {
  // Get and validate brief content
  const briefElement = document.getElementById('brief');
  const briefContent = briefElement.value.trim();
  
  // Validate that brief is not empty
  if (!briefContent) {
    alert('Product brief is required. Please provide a description of your product or feature before exporting to PDF.');
    briefElement.focus();
    briefElement.classList.add('input-error');
    return;
  }
  
  // Remove error styling if it was previously applied
  briefElement.classList.remove('input-error');
  
  const { jsPDF } = window.jspdf;
  const doc = new jsPDF('p', 'mm', 'a4');
  const resultSection = document.getElementById('result');
  const exportBtn = document.getElementById('export-pdf-btn');
  
  // Show loading state
  const originalBtnText = exportBtn.innerHTML;
  exportBtn.innerHTML = '<span class="btn-icon">‚è≥</span>Generating PDF...';
  exportBtn.disabled = true;
  
  try {
    // Get execution ID from URL or current state
    const executionId = getCurrentExecutionId();
    const title = `Aivar Product Analysis - ${new Date().toLocaleDateString()}`;
    const briefContent = document.getElementById('brief')?.value || 'N/A';
    
    // Define colors
    const colors = {
      blue: [75, 86, 210],      // Aivar blue
      purple: [130, 38, 158],   // Aivar purple
      gold: [241, 201, 59],     // Aivar gold
      text: [35, 41, 74],       // Dark text
      textSecondary: [100, 100, 100], // Secondary text
      lightGray: [248, 249, 252], // Light gray background
      lightBlue: [238, 241, 248], // Light blue for accents
      accentGreen: [72, 187, 120], // Accent green for highlights
      borderGray: [226, 232, 240]  // Border color
    };
    
    // Set document properties
    doc.setProperties({
      title: title,
      subject: 'Product Analysis Report',
      author: 'Aivar AI',
      keywords: 'product analysis, aivar, report',
      creator: 'Aivar Product Analysis Tool'
    });
    
    // Add cover page with gradient-like effect
    // Background base
    doc.setFillColor(...colors.lightGray);
    doc.rect(0, 0, doc.internal.pageSize.getWidth(), doc.internal.pageSize.getHeight(), 'F');
    
    // Top accent bar
    doc.setFillColor(...colors.blue);
    doc.rect(0, 0, doc.internal.pageSize.getWidth(), 15, 'F');
    
    // Side accent
    doc.setFillColor(...colors.purple);
    doc.rect(0, 15, 15, doc.internal.pageSize.getHeight() - 15, 'F');
    
    // Decorative elements
    for (let i = 0; i < 5; i++) {
      const opacity = 0.1 - (i * 0.015);
      doc.setFillColor(...colors.blue, opacity);
      doc.circle(25, 35, 60 - (i * 10), 'F');
      
      doc.setFillColor(...colors.purple, opacity);
      doc.circle(doc.internal.pageSize.getWidth() - 25, 
                doc.internal.pageSize.getHeight() - 40, 
                50 - (i * 8), 'F');
    }
    
    // Add logo placeholder with modern design
    doc.setFillColor(...colors.blue);
    doc.roundedRect(doc.internal.pageSize.getWidth() / 2 - 25, 50, 50, 50, 8, 8, 'F');
    
    // Logo inner accent
    doc.setFillColor(...colors.gold);
    doc.roundedRect(doc.internal.pageSize.getWidth() / 2 - 15, 60, 30, 30, 5, 5, 'F');
    
    doc.setTextColor(255, 255, 255);
    doc.setFontSize(28);
    doc.setFont('helvetica', 'bold');
    doc.text('A', doc.internal.pageSize.getWidth() / 2, 80, { align: 'center' });
    
    // Add title with enhanced styling
    doc.setTextColor(...colors.text);
    doc.setFontSize(32);
    doc.setFont('helvetica', 'bold');
    doc.text('Product Analysis', doc.internal.pageSize.getWidth() / 2, 130, { align: 'center' });
    
    doc.setFontSize(34);
    doc.setTextColor(...colors.blue);
    doc.text('Report', doc.internal.pageSize.getWidth() / 2, 150, { align: 'center' });
    
    // Add subtitle with date in a more elegant format
    doc.setTextColor(...colors.textSecondary);
    doc.setFontSize(14);
    doc.setFont('helvetica', 'normal');
    
    // Format date in a more readable way
    const dateOptions = { year: 'numeric', month: 'long', day: 'numeric' };
    const formattedDate = new Date().toLocaleDateString(undefined, dateOptions);
    doc.text(`Generated on ${formattedDate}`, doc.internal.pageSize.getWidth() / 2, 170, { align: 'center' });
    
    // Add execution ID with better styling
    doc.setFillColor(...colors.lightBlue);
    doc.roundedRect(doc.internal.pageSize.getWidth() / 2 - 40, 180, 80, 15, 3, 3, 'F');
    
    doc.setFontSize(10);
    doc.setTextColor(...colors.blue);
    doc.text(`Report ID: ${executionId || 'N/A'}`, doc.internal.pageSize.getWidth() / 2, 190, { align: 'center' });
    
    // Add decorative elements
    doc.setDrawColor(...colors.purple);
    doc.setLineWidth(1.5);
    doc.line(doc.internal.pageSize.getWidth() / 2 - 40, 140, doc.internal.pageSize.getWidth() / 2 + 40, 140);
    
    // Add footer to cover page
    doc.setTextColor(...colors.textSecondary);
    doc.setFontSize(10);
    doc.text('Powered by Aivar AI', doc.internal.pageSize.getWidth() / 2, doc.internal.pageSize.getHeight() - 20, { align: 'center' });
    
    // Add Table of Contents page
    doc.addPage();
    doc.setTextColor(...colors.blue);
    doc.setFontSize(20);
    doc.setFont('helvetica', 'bold');
    doc.text('Table of Contents', 20, 20);
    
    doc.setDrawColor(...colors.purple);
    doc.setLineWidth(0.5);
    doc.line(20, 25, 190, 25);
    
    // Collect section titles for TOC
    const agentCards = resultSection.querySelectorAll('.agent-card');
    const toc = [];
    let pageNum = 3; // Starting from page 3 (after cover and TOC)
    
    agentCards.forEach((card, index) => {
      const title = card.querySelector('.agent-title')?.textContent || `Section ${index + 1}`;
      toc.push({ title, page: pageNum });
      pageNum++; // Each section will start on a new page
    });
    
    // Add brief summary section to TOC
    toc.unshift({ title: 'Brief Summary', page: 3 });
    pageNum++; // Increment for the additional page
    
    // Render TOC
    let tocY = 40;
    doc.setTextColor(...colors.text);
    doc.setFontSize(12);
    doc.setFont('helvetica', 'normal');
    
    toc.forEach(item => {
      doc.text(item.title, 25, tocY);
      doc.text(item.page.toString(), 190, tocY, { align: 'right' });
      doc.setDrawColor(200, 200, 200);
      doc.setLineWidth(0.2);
      doc.line(25, tocY + 2, 190, tocY + 2);
      tocY += 15;
    });
    
    // Add Brief Summary page
    doc.addPage();
    doc.setTextColor(...colors.blue);
    doc.setFontSize(20);
    doc.setFont('helvetica', 'bold');
    doc.text('Brief Summary', 20, 20);
    
    doc.setDrawColor(...colors.purple);
    doc.setLineWidth(0.5);
    doc.line(20, 25, 190, 25);
    
    // Add brief content
    doc.setTextColor(...colors.text);
    doc.setFontSize(11);
    doc.setFont('helvetica', 'normal');
    
    // Split brief into multiple lines
    const splitBrief = doc.splitTextToSize(briefContent, 170);
    doc.text(splitBrief, 20, 40);
    
    // Process each agent card on its own page
    for (const card of agentCards) {
      doc.addPage();
      
      // Get agent title
      const agentTitle = card.querySelector('.agent-title')?.textContent || 'Agent Analysis';
      
      // Add section header
      doc.setTextColor(...colors.blue);
      doc.setFontSize(20);
      doc.setFont('helvetica', 'bold');
      doc.text(agentTitle, 20, 20);
      
      doc.setDrawColor(...colors.purple);
      doc.setLineWidth(0.5);
      doc.line(20, 25, 190, 25);
      
      // Try to extract text content first for better quality
      const sections = card.querySelectorAll('.section-accordion');
      let yPosition = 35;
      
      if (sections.length > 0) {
        // Process each section as text when possible
        for (const section of sections) {
          const sectionHeader = section.querySelector('.section-header')?.textContent?.trim() || 'Section';
          const sectionContent = section.querySelector('.section-content');
          
          // Add section header with improved styling
          // Add section header background
          doc.setFillColor(...colors.lightBlue);
          doc.roundedRect(15, yPosition - 7, doc.internal.pageSize.getWidth() - 30, 14, 3, 3, 'F');
          
          // Add accent marker
          doc.setFillColor(...colors.purple);
          doc.rect(15, yPosition - 7, 5, 14, 'F');
          
          doc.setTextColor(...colors.blue);
          doc.setFontSize(14);
          doc.setFont('helvetica', 'bold');
          doc.text(sectionHeader, 25, yPosition);
          yPosition += 12;
          
          // Add section content
          doc.setTextColor(...colors.text);
          doc.setFontSize(11);
          doc.setFont('helvetica', 'normal');
          
          if (sectionContent) {
            // Try to get text content
            let contentText = sectionContent.textContent?.trim() || 'No content';
            
            // Split text into multiple lines
            const splitText = doc.splitTextToSize(contentText, 170);
            
            // Check if content will fit on current page
            if (yPosition + (splitText.length * 5) > doc.internal.pageSize.getHeight() - 20) {
              doc.addPage();
              yPosition = 20;
            }
            
            // Calculate content height
            const contentHeight = (splitText.length * 5) + 15;
            
            // Adjust content background height
            doc.setFillColor(255, 255, 255);
            doc.roundedRect(15, yPosition - 5, doc.internal.pageSize.getWidth() - 30, contentHeight, 3, 3, 'F');
            
            // Add subtle border
            doc.setDrawColor(...colors.borderGray);
            doc.setLineWidth(0.5);
            doc.roundedRect(15, yPosition - 5, doc.internal.pageSize.getWidth() - 30, contentHeight, 3, 3, 'S');
            
            doc.text(splitText, 25, yPosition);
            yPosition += (splitText.length * 5) + 15;
          } else {
            doc.text('No content available', 20, yPosition);
            yPosition += 10;
          }
          
          // Add some spacing between sections
          yPosition += 5;
          
          // Check if we need a new page for the next section
          if (yPosition > doc.internal.pageSize.getHeight() - 30) {
            doc.addPage();
            yPosition = 20;
          }
        }
      } else {
        // Fallback to image capture if structured sections aren't available
        const canvas = await html2canvas(card, {
          scale: 2, // Higher resolution
          logging: false,
          useCORS: true
        });
        
        const imgData = canvas.toDataURL('image/png');
        const imgWidth = doc.internal.pageSize.getWidth() - 40; // 20mm margins on each side
        const imgHeight = (canvas.height * imgWidth) / canvas.width;
        
        // Add the image to the PDF
        doc.addImage(imgData, 'PNG', 20, 35, imgWidth, imgHeight);
      }
    }
    
    // Add footer to all pages (except cover) with improved styling
    const pageCount = doc.internal.getNumberOfPages();
    const pageWidth = doc.internal.pageSize.getWidth();
    
    for (let i = 2; i <= pageCount; i++) {
      doc.setPage(i);
      
      // Add footer background
      doc.setFillColor(...colors.lightBlue);
      doc.rect(0, doc.internal.pageSize.getHeight() - 20, pageWidth, 20, 'F');
      
      // Add page number with better styling
      doc.setFillColor(255, 255, 255);
      doc.circle(pageWidth / 2, doc.internal.pageSize.getHeight() - 10, 8, 'F');
      
      doc.setTextColor(...colors.blue);
      doc.setFontSize(9);
      doc.setFont('helvetica', 'bold');
      doc.text(`${i - 1}`, pageWidth / 2, doc.internal.pageSize.getHeight() - 7, { align: 'center' });
      
      // Add total pages indicator
      doc.setTextColor(255, 255, 255);
      doc.setFontSize(8);
      doc.setFont('helvetica', 'normal');
      doc.text(`of ${pageCount - 1}`, pageWidth / 2 + 12, doc.internal.pageSize.getHeight() - 7, { align: 'left' });
      
      // Add Aivar branding
      doc.setTextColor(255, 255, 255);
      doc.setFontSize(9);
      doc.setFont('helvetica', 'bold');
      doc.text('Aivar AI', 15, doc.internal.pageSize.getHeight() - 7);
      
      // Add date on right
      doc.setTextColor(255, 255, 255);
      doc.setFontSize(8);
      doc.setFont('helvetica', 'normal');
      doc.text(new Date().toLocaleDateString(), pageWidth - 15, doc.internal.pageSize.getHeight() - 7, { align: 'right' });
    }
    
    // Save the PDF
    const pdfBlob = new Blob([doc.output()], { type: 'application/pdf' });
    const pdfUrl = URL.createObjectURL(pdfBlob);
    
    // Display the PDF in the modal
    const iframe = document.getElementById('pdf-preview-iframe');
    iframe.src = pdfUrl;
    const modal = document.getElementById('pdf-preview-modal');
    modal.style.display = 'block';
  } catch (err) {
    console.error('Error generating PDF:', err);
    alert('Failed to generate PDF. Please try again.');
  } finally {
    // Restore button state
    exportBtn.innerHTML = originalBtnText;
    exportBtn.disabled = false;
  }
}

// Get current execution ID from various possible sources
function getCurrentExecutionId() {
  // Try to get from URL if available
  const urlParams = new URLSearchParams(window.location.search);
  const idFromUrl = urlParams.get('execution');
  if (idFromUrl) return idFromUrl;
  
  // Try to get from selected execution in sidebar
  const selectedExecution = document.querySelector('.execution-item.selected');
  if (selectedExecution) return selectedExecution.dataset.id;
  
  // Try to get from last completed execution status
  return window.lastCompletedExecutionId || null;
}

// Generate PDF for preview only
async function previewPDF() {
  const { jsPDF } = window.jspdf;
  const doc = new jsPDF('p', 'mm', 'a4');
  const resultSection = document.getElementById('result');
  const previewBtn = document.getElementById('preview-pdf-btn');
  
  // Show loading state
  const originalBtnText = previewBtn.innerHTML;
  previewBtn.innerHTML = '<span class="btn-icon">‚è≥</span>Generating Preview...';
  previewBtn.disabled = true;
  
  try {
    // Get execution ID from URL or current state
    const executionId = getCurrentExecutionId();
    
    // Get brief content
    const briefContent = document.getElementById('brief').value.trim() || 'No product brief provided';
    
    // Define colors for consistent styling
    const colors = {
      blue: [75, 86, 210],      // Aivar blue
      purple: [130, 38, 158],   // Aivar purple
      gold: [241, 201, 59],     // Gold accent
      text: [35, 41, 74],       // Main text color
      textSecondary: [100, 100, 100], // Secondary text
      lightGray: [248, 249, 252], // Light gray background
      lightBlue: [238, 241, 248], // Light blue for accents
      accentGreen: [72, 187, 120], // Accent green for highlights
      borderGray: [226, 232, 240]  // Border color
    };
    
    // Add cover page with gradient-like effect
    // Background base
    doc.setFillColor(...colors.lightGray);
    doc.rect(0, 0, doc.internal.pageSize.getWidth(), doc.internal.pageSize.getHeight(), 'F');
    
    // Top accent bar
    doc.setFillColor(...colors.blue);
    doc.rect(0, 0, doc.internal.pageSize.getWidth(), 15, 'F');
    
    // Side accent
    doc.setFillColor(...colors.purple);
    doc.rect(0, 15, 15, doc.internal.pageSize.getHeight() - 15, 'F');
    
    // Decorative elements
    for (let i = 0; i < 5; i++) {
      const opacity = 0.1 - (i * 0.015);
      doc.setFillColor(...colors.blue, opacity);
      doc.circle(25, 35, 60 - (i * 10), 'F');
      
      doc.setFillColor(...colors.purple, opacity);
      doc.circle(doc.internal.pageSize.getWidth() - 25, 
                doc.internal.pageSize.getHeight() - 40, 
                50 - (i * 8), 'F');
    }
    
    // Add logo placeholder with modern design
    doc.setFillColor(...colors.blue);
    doc.roundedRect(doc.internal.pageSize.getWidth() / 2 - 25, 50, 50, 50, 8, 8, 'F');
    
    // Logo inner accent
    doc.setFillColor(...colors.gold);
    doc.roundedRect(doc.internal.pageSize.getWidth() / 2 - 15, 60, 30, 30, 5, 5, 'F');
    
    // Add logo text
    doc.setTextColor(255, 255, 255);
    doc.setFontSize(28);
    doc.setFont('helvetica', 'bold');
    doc.text('A', doc.internal.pageSize.getWidth() / 2, 80, { align: 'center' });
    
    // Add title with enhanced styling
    doc.setTextColor(...colors.text);
    doc.setFontSize(32);
    doc.setFont('helvetica', 'bold');
    doc.text('Product Analysis', doc.internal.pageSize.getWidth() / 2, 130, { align: 'center' });
    
    doc.setFontSize(34);
    doc.setTextColor(...colors.blue);
    doc.text('Report', doc.internal.pageSize.getWidth() / 2, 150, { align: 'center' });
    
    // Add subtitle with date in a more elegant format
    doc.setTextColor(...colors.textSecondary);
    doc.setFontSize(14);
    doc.setFont('helvetica', 'normal');
    
    // Format date in a more readable way
    const dateOptions = { year: 'numeric', month: 'long', day: 'numeric' };
    const formattedDate = new Date().toLocaleDateString(undefined, dateOptions);
    doc.text(`Generated on ${formattedDate}`, doc.internal.pageSize.getWidth() / 2, 170, { align: 'center' });
    
    // Add execution ID with better styling
    doc.setFillColor(...colors.lightBlue);
    doc.roundedRect(doc.internal.pageSize.getWidth() / 2 - 40, 180, 80, 15, 3, 3, 'F');
    
    doc.setFontSize(10);
    doc.setTextColor(...colors.blue);
    doc.text(`Report ID: ${executionId || 'N/A'}`, doc.internal.pageSize.getWidth() / 2, 190, { align: 'center' });
    
    // Add decorative elements
    doc.setDrawColor(...colors.purple);
    doc.setLineWidth(1.5);
    doc.line(doc.internal.pageSize.getWidth() / 2 - 40, 140, doc.internal.pageSize.getWidth() / 2 + 40, 140);
    
    // Add footer to cover page
    doc.setTextColor(...colors.textSecondary);
    doc.setFontSize(10);
    doc.text('Powered by Aivar AI', doc.internal.pageSize.getWidth() / 2, doc.internal.pageSize.getHeight() - 20, { align: 'center' });
    
    // We've already styled the cover page, so we don't need the content area here
    // The content will be added on subsequent pages with proper styling
    
    // Add decorative elements
    doc.setDrawColor(...colors.purple);
    doc.setLineWidth(1.5);
    doc.line(doc.internal.pageSize.getWidth() / 2 - 40, 140, doc.internal.pageSize.getWidth() / 2 + 40, 140);
    
    // Add footer to cover page
    doc.setTextColor(...colors.textSecondary);
    doc.setFontSize(10);
    doc.text('Powered by Aivar AI', doc.internal.pageSize.getWidth() / 2, doc.internal.pageSize.getHeight() - 20, { align: 'center' });
    
    // Add Table of Contents page
    doc.addPage();
    doc.setTextColor(...colors.blue);
    doc.setFontSize(20);
    doc.setFont('helvetica', 'bold');
    doc.text('Table of Contents', 20, 20);
    
    doc.setDrawColor(...colors.purple);
    doc.setLineWidth(0.5);
    doc.line(20, 25, 190, 25);
    
    // Collect section titles for TOC
    const agentCards = resultSection.querySelectorAll('.agent-card');
    const toc = [];
    let pageNum = 3; // Starting from page 3 (after cover and TOC)
    
    agentCards.forEach((card, index) => {
      const title = card.querySelector('.agent-title')?.textContent || `Section ${index + 1}`;
      toc.push({ title, page: pageNum });
      pageNum++; // Each section will start on a new page
    });
    
    // Add brief summary section to TOC
    toc.unshift({ title: 'Brief Summary', page: 3 });
    pageNum++; // Increment for the additional page
    
    // Render TOC
    let tocY = 40;
    doc.setTextColor(...colors.text);
    doc.setFontSize(12);
    doc.setFont('helvetica', 'normal');
    
    toc.forEach(item => {
      doc.text(item.title, 25, tocY);
      doc.text(item.page.toString(), 190, tocY, { align: 'right' });
      doc.setDrawColor(200, 200, 200);
      doc.setLineWidth(0.2);
      doc.line(25, tocY + 2, 190, tocY + 2);
      tocY += 15;
    });
    
    // Add Brief Summary page
    doc.addPage();
    doc.setTextColor(...colors.blue);
    doc.setFontSize(20);
    doc.setFont('helvetica', 'bold');
    doc.text('Brief Summary', 20, 20);
    
    doc.setDrawColor(...colors.purple);
    doc.setLineWidth(0.5);
    doc.line(20, 25, 190, 25);
    
    // Add brief content
    doc.setTextColor(...colors.text);
    doc.setFontSize(11);
    doc.setFont('helvetica', 'normal');
    
    // Split brief into multiple lines
    const splitBrief = doc.splitTextToSize(briefContent, 170);
    doc.text(splitBrief, 20, 40);
    
    // Process each agent card on its own page
    for (const card of agentCards) {
      doc.addPage();
      
      // Get agent title
      const agentTitle = card.querySelector('.agent-title')?.textContent || 'Agent Analysis';
      
      // Add section header
      doc.setTextColor(...colors.blue);
      doc.setFontSize(20);
      doc.setFont('helvetica', 'bold');
      doc.text(agentTitle, 20, 20);
      
      doc.setDrawColor(...colors.purple);
      doc.setLineWidth(0.5);
      doc.line(20, 25, 190, 25);
      
      // Try to extract text content first for better quality
      const sections = card.querySelectorAll('.section-accordion');
      let yPosition = 35;
      
      if (sections.length > 0) {
        // Process each section as text when possible
        for (const section of sections) {
          const sectionHeader = section.querySelector('.section-header')?.textContent?.trim() || 'Section';
          const sectionContent = section.querySelector('.section-content');
          
          // Add section header
          doc.setTextColor(...colors.blue);
          doc.setFontSize(14);
          doc.setFont('helvetica', 'bold');
          doc.text(sectionHeader, 20, yPosition);
          yPosition += 8;
          
          // Add section content
          doc.setTextColor(...colors.text);
          doc.setFontSize(11);
          doc.setFont('helvetica', 'normal');
          
          // Get text content
          let contentText = sectionContent?.textContent?.trim() || 'No content available';
          
          // Split text into lines to fit page width
          const contentLines = doc.splitTextToSize(contentText, 170);
          
          // Check if content will fit on current page
          if (yPosition + contentLines.length * 5 > doc.internal.pageSize.getHeight() - 20) {
            doc.addPage();
            yPosition = 20;
          }
          
          doc.text(contentLines, 20, yPosition);
          yPosition += contentLines.length * 5 + 10;
          
          // Add separator
          doc.setDrawColor(220, 220, 220);
          doc.setLineWidth(0.2);
          doc.line(20, yPosition - 5, 190, yPosition - 5);
          
          // Check if we need a new page for next section
          if (yPosition > doc.internal.pageSize.getHeight() - 40) {
            doc.addPage();
            yPosition = 20;
          }
        }
      } else {
        // Fallback to image capture if structured sections aren't available
        const canvas = await html2canvas(card, {
          scale: 2, // Higher resolution
          logging: false,
          useCORS: true
        });
        
        const imgData = canvas.toDataURL('image/png');
        const imgWidth = doc.internal.pageSize.getWidth() - 40; // 20mm margins on each side
        const imgHeight = (canvas.height * imgWidth) / canvas.width;
        
        // Add the image to the PDF
        doc.addImage(imgData, 'PNG', 20, 35, imgWidth, imgHeight);
      }
    }
    
    // Add footer to all pages (except cover)
    const pageCount = doc.internal.getNumberOfPages();
    const pageWidth = doc.internal.pageSize.getWidth();
    
    for (let i = 2; i <= pageCount; i++) {
      doc.setPage(i);
      doc.setFontSize(8);
      doc.setTextColor(...colors.textSecondary);
      
      // Add page number
      doc.text(`Page ${i - 1} of ${pageCount - 1}`, pageWidth / 2, doc.internal.pageSize.getHeight() - 10, { align: 'center' });
      
      // Add footer line
      doc.setDrawColor(200, 200, 200);
      doc.setLineWidth(0.2);
      doc.line(20, doc.internal.pageSize.getHeight() - 15, pageWidth - 20, doc.internal.pageSize.getHeight() - 15);
      
      // Add Aivar branding
      doc.setTextColor(...colors.blue);
      doc.text('Aivar AI', 20, doc.internal.pageSize.getHeight() - 10);
      
      // Add date on right
      doc.setTextColor(...colors.textSecondary);
      doc.text(new Date().toLocaleDateString(), pageWidth - 20, doc.internal.pageSize.getHeight() - 10, { align: 'right' });
    }
    
    // Generate PDF blob and display in modal
    const pdfBlob = doc.output('blob');
    const pdfUrl = URL.createObjectURL(pdfBlob);
    
    // Display the PDF in the modal
    const iframe = document.getElementById('pdf-preview-iframe');
    iframe.src = pdfUrl;
    const modal = document.getElementById('pdf-preview-modal');
    modal.style.display = 'block';
  } catch (err) {
    console.error('Error generating PDF preview:', err);
    alert('Failed to generate PDF preview. Please try again.');
  } finally {
    // Restore button state
    previewBtn.innerHTML = originalBtnText;
    previewBtn.disabled = false;
  }
}

// ========== Document Ready ===========
document.addEventListener('DOMContentLoaded', function() {
  document.getElementById('submit-btn').addEventListener('click', submitWorkflow);
  
  // Initialize PDF export button
  document.getElementById('export-pdf-btn').addEventListener('click', exportToPDF);
  
  // Initialize PDF preview button
  document.getElementById('preview-pdf-btn').addEventListener('click', previewPDF);
  
  // Set up PDF preview close button
  document.getElementById('pdf-preview-close').addEventListener('click', function() {
    const modal = document.getElementById('pdf-preview-modal');
    modal.style.display = 'none';
    
    // Clean up the object URL to prevent memory leaks
    const iframe = document.getElementById('pdf-preview-iframe');
    if (iframe.src) {
      URL.revokeObjectURL(iframe.src);
      iframe.src = '';
    }
  });
  
  // Close modal when clicking outside the content
  document.getElementById('pdf-preview-modal').addEventListener('click', function(event) {
    if (event.target === this) {
      this.style.display = 'none';
      
      // Clean up the object URL
      const iframe = document.getElementById('pdf-preview-iframe');
      if (iframe.src) {
        URL.revokeObjectURL(iframe.src);
        iframe.src = '';
      }
    }
  });
  
  // Initialize file upload handler
  handleFileSelect();
  
  renderExampleCards();
  
  // Load executions list
  loadExecutions();
  
  // Initialize accordions
  initAccordions();
});